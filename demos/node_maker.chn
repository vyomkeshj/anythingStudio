{"version":"0.0.3","content":{"nodes":[{"data":{"schemaId":"machines:langchain:todo_list_plugin","inputData":{},"id":"11227109-271f-4756-8415-175f97c2b999","outputChannelData":[]},"id":"11227109-271f-4756-8415-175f97c2b999","position":{"x":208,"y":512},"type":"regularNode","selected":false,"height":99,"width":240,"zIndex":50},{"data":{"schemaId":"machines:text:text_large","inputData":{"0":"You are an experienced full stacked developer. You are tasked at building software using a new framework that represents the system as a graph. You always generate clean and concise code. Each Node has a python component that serves as backend and a react component that gets rendered on the frontend. The communication between the nodes happens by using web-sockets. The python node defines itself by subclassing NodeBase:\n``` python\nNodeType = Literal[\"regularNode\", \"iterator\", \"iteratorHelper\"]\n\n\nclass NodeBase(metaclass=ABCMeta):\n    \"\"\"Base class for a node\"\"\"\n\n    def __init__(self):\n        self.__inputs: List[BaseInput] = []\n        self.__outputs: List[BaseOutput] = []\n        self.__group_layout: List[Union[InputId, NestedIdGroup]] = []\n        self.description: str = \"\"\n\n        self.category: Category = Category(\n            \"Unknown\", \"Unknown category\", \"BsQuestionDiamond\", \"#718096\"\n        )\n        self.name: str = \"\"\n        self.icon: str = \"\"\n        self.sub: str = \"Miscellaneous\"\n        self.type: NodeType = \"regularNode\"\n\n        self.side_effects: bool = False\n        self.deprecated: bool = False\n\n        self.node_id: NodeId = None\n\n        self.event_loop: asyncio.AbstractEventLoop = None   # type: ignore\n\n    def set_node_id(self, node_id: NodeId):\n        self.node_id = node_id\n\n    def set_output_id_for_channel(self, channel_name: str, channel_id: str):\n        # fixme: assumes channel names are never same across outputs\n        for output in self.outputs:\n            output.set_channel_id_by_name(channel_name, channel_id)\n\n    def set_event_loop(self, event_loop):\n        self.event_loop = event_loop\n\n    @property\n    def inputs(self) -> List[BaseInput]:\n        return self.__inputs\n\n    @inputs.setter\n    def inputs(self, value: List[Union[BaseInput, NestedGroup]]):\n        inputs: List[BaseInput] = []\n        groups = []\n\n        def add_inputs(\n            current: List[Union[BaseInput, NestedGroup]]\n        ) -> List[Union[InputId, NestedIdGroup]]:\n            layout: List[Union[InputId, NestedIdGroup]] = []\n\n            for x in current:\n                if isinstance(x, Group):\n                    if x.info.id == -1:\n                        x.info.id = GroupId(len(groups))\n                    g: NestedIdGroup = Group(x.info, [])\n                    groups.append(g)\n                    layout.append(g)\n                    g.items.extend(add_inputs(x.items))  # type: ignore\n                else:\n                    if x.id == -1:\n                        x.id = InputId(len(inputs))\n                    layout.append(x.id)\n                    inputs.append(x)\n\n            return layout\n\n        self.__inputs = inputs\n        self.__group_layout = add_inputs(value)\n\n    @property\n    def outputs(self) -> List[BaseOutput]:\n        return self.__outputs\n\n    @outputs.setter\n    def outputs(self, value: List[BaseOutput]):\n        for i, output_value in enumerate(value):\n            if output_value.id == -1:\n                output_value.id = OutputId(i)\n        self.__outputs = value\n\n    @property\n    def group_layout(self) -> List[Union[InputId, NestedIdGroup]]:\n        return self.__group_layout\n\n    def get_outputs(self) -> List[BaseOutput]:\n        return self.__outputs\n\n    @abstractmethod\n    def run(self) -> Any:\n        \"\"\"Abstract method to run a node's logic\"\"\"\n        return\n\n    async def run_async(self):\n        \"\"\"Implement when something needs to keep running\"\"\"\n        return\n\n```\nEvery node must define it's outputs, it is used to send the react component the correct props:\n```\nfrom __future__ import annotations\n\nfrom typing import Literal, Union, List\n\nfrom base_types import OutputId\nimport json\n\nfrom src.events import UIEventChannel, ToUIOutputMessage, UIEvtChannelSchema\nfrom .. import expression\n\nOutputKind = Literal[\"dataframe\", \"chat\", \"image\", \"large-image\", \"tagged\", \"generic\"]\n\n\nclass BaseOutput:\n    def __init__(\n            self,\n            output_type: expression.ExpressionJson,\n            label: str,\n            kind: OutputKind = \"generic\",\n            has_handle: bool = True,\n            channels=None,\n    ):\n        if channels is None:\n            channels = []\n\n        self.output_type: expression.ExpressionJson = output_type\n        self.label: str = label\n        self.id: OutputId = OutputId(-1)\n        self.never_reason: Union[str, None] = None\n\n        # if the component is a live component\n        self.ui_message_registry: List[UIEvtChannelSchema] = channels\n        self.kind: OutputKind = kind\n        self.has_handle: bool = has_handle\n\n        self.uplink_channel: UIEventChannel = None  # type ignore\n        self.downlink_channel: UIEventChannel = None  # type ignore\n\n\n    def toDict(self):\n            return {\n                \"id\": self.id,\n                \"type\": self.output_type,\n                \"label\": self.label,\n                \"neverReason\": self.never_reason,\n                \"kind\": self.kind,\n                \"hasHandle\": self.has_handle,\n                \"ui_message_registry\": self.ui_message_registry,\n            }\n\n    def get_channel_id_by_name(self, channel_name: str):\n        for channel in self.ui_message_registry:\n            if channel['channel_name'] == channel_name:\n                return channel['channel_id']\n        return None\n\n    def set_channel_id_by_name(self, channel_name: str, channel_id: str):\n        for channel in self.ui_message_registry:\n            if channel['channel_name'] == channel_name:\n                channel['channel_id'] = channel_id\n                return\n        return None\n\n    def provide_channel_to_output(self, channel: UIEventChannel):\n        \"\"\"When the nodes are received from the ui, the backend provides the nodes channels to comm with the ui\"\"\"\n        self.uplink_channel = channel\n\n    def provide_channel_for_input(self, channel: UIEventChannel):\n        \"\"\"This channel fetches events from the ui and sends them to the node\"\"\"\n        self.downlink_channel = channel\n\n    async def send_ui_event(self, event: ToUIOutputMessage):\n        await self.uplink_channel.put(event)\n\n    async def receive_ui_event(self, channel_name: str):\n        \"\"\"Receives ui event for a given channel name for the output\"\"\"\n        return await self.downlink_channel.get_message(self.get_channel_id_by_name(channel_name))\n\n    def with_id(self, output_id: Union[OutputId, int]):\n        self.id = OutputId(output_id)\n        return self\n\n    def with_never_reason(self, reason: str):\n        self.never_reason = reason\n        return self\n\n    def __repr__(self):\n        return str(self.toDict())\n\n    def __iter__(self):\n        yield from self.toDict().items()\n\n    def get_broadcast_data(self, _value):\n        return None\n\n    def get_broadcast_type(self, _value) -> expression.ExpressionJson | None:\n        return None\n\n    def validate(self, value) -> None:\n        assert value is not None\n\n\nclass ChatOutput(BaseOutput):\n    def __init__(\n            self,\n            model_type: expression.ExpressionJson = \"string\",\n            label: str = \"Chat Viewer\",\n            kind: OutputKind = \"chat\",\n    ):\n        ui_channels = [UIEvtChannelSchema(channel_name='msg_from_chatbot',\n                                          channel_direction='uplink',\n                                          channel_id=''),\n                       UIEvtChannelSchema(channel_name='msg_from_user',\n                                          channel_direction='downlink',\n                                          channel_id='')]\n\n        super().__init__(model_type, label, kind=kind, channels=ui_channels, has_handle=False)\n\n    def get_broadcast_data(self, value: str):\n        return value\n\n    async def send_ui_event(self, event: ToUIOutputMessage):\n        await self.uplink_channel.put(event)\n```\nAn example for a Node that exposes a chatbox on the ui and echos the user's message as response is here:\n```\nfrom enum import Enum\nfrom typing import TypedDict\n\nfrom sanic.log import logger\n\nfrom src.events import ToUIOutputMessage\nfrom ...io.outputs.chat_output import ChatOutput\nfrom ...node_base import NodeBase\nfrom ...node_factory import NodeFactory\nfrom ...io.inputs import TextLineInput\nfrom . import category as ChatCategory\n\nimport asyncio\n\n\nclass MsgFromUser(TypedDict):\n    msg: str\n\n\nclass MsgFromChatbot(TypedDict):\n    msg: str\n\n\nclass Models(Enum):\n    GPT3 = \"text-davinci-003\"\n    GPT35 = \"gpt-3.5-turbo\"\n\n\n# some way to just tag this as websocket node?\n@NodeFactory.register(\"machines:database:chat_node\")\nclass ChatQComponent(NodeBase):\n    def __init__(self):\n        super().__init__()\n        self.description = \"Chat with your database.\"\n        self.inputs = [\n            TextLineInput(\"ModelName\", default=\"gpt-3.5-turbo\")\n        ]\n        self.chat_output = ChatOutput()\n        self.outputs = [self.chat_output]\n\n        self.category = ChatCategory\n        self.sub = \"Dbase\"\n        self.name = \"ChatQ\"\n        self.icon = \"BsFillDatabaseFill\"\n\n        self.side_effects = True\n\n    def run(self, use_model: str) -> str:\n        \"\"\"\n            Initializes the chat node\n        \"\"\"\n\n        return ''\n\n    async def run_async(self):\n        await self.send_ui_event(MsgFromChatbot(msg=\"gonna say what you say 5 sec later\"))\n\n        while True:\n            received = await self.receive_ui_event()\n            if received['msg'] == 'quit':\n                break\n            await asyncio.sleep(5)\n            await self.send_ui_event(MsgFromChatbot(msg=f\"Echo: {received['msg']}\"))\n\n    async def send_ui_event(self, message: MsgFromChatbot):\n        channel_id = self.chat_output.get_channel_id_by_name('msg_from_chatbot')\n\n        out_message = ToUIOutputMessage(channel_id=channel_id,\n                                        data=message,\n                                        message_tag=\"msg_from_chatbot\")\n        await self.chat_output.send_ui_event(event=out_message)\n\n    async def receive_ui_event(self) -> MsgFromUser:\n        event = await self.chat_output.receive_ui_event(channel_name='msg_from_user')\n        return event['data']\n```\nAnd the react typescript component for the ui:\nimport { Flex } from \"@chakra-ui/react\";\nimport React, { memo, useEffect, useState } from \"react\";\nimport Divider from \"./components/Divider\";\nimport Footer from \"./components/Footer\";\nimport Header from \"./components/Header\";\nimport Messages from \"./components/Messages\";\nimport { OutputProps } from \"../props\";\nimport log from \"electron-log\";\nimport { ToUIOutputMessage } from \"../../../../common/ui_event_messages\";\nimport { useWebSocketUILink } from \"../../../hooks/useWebSocketUILink\";\n\ninterface MsgFromChatbot {\n  msg: string;\n}\n\ninterface MsgFromUser {\n  msg: string;\n}\n\nconst ChatComponent = memo(({ label, id, outputId, schemaId, ui_message_registry }: OutputProps) => {\n  const [messages, setMessages] = useState([\n    { from: \"computer\", text: \"Hi, My Name is ChatQ, Please connect the database and press run to begin!\" },\n  ]);\n  const [inputMessage, setInputMessage] = useState(\"\");\n\n  const handle_from_chatbot_msg = (message: ToUIOutputMessage<MsgFromChatbot>) => {\n    log.info(\"Got message from chatbot_x: \", message);\n    setMessages((old) => [...old, { from: \"computer\", text: message.data.msg }]);\n  };\n\n  const handlers = {\n    'msg_from_chatbot': handle_from_chatbot_msg,\n  };\n\n  const { sendMessage } = useWebSocketUILink(handlers, ui_message_registry);\n\n  const handleSendMessage = () => {\n    if (!inputMessage.trim().length) {\n      return;\n    }\n    const data = inputMessage;\n    console.log(data);\n    setMessages((old) => [...old, { from: \"me\", text: data }]);\n    setInputMessage(\"\");\n\n    const message: MsgFromUser = {\n      msg: data,\n    };\n\n    sendMessage('msg_from_user', message);\n  };\n\n  return (\n    <Flex w=\"500dp\" h=\"300dp\" justify=\"center\" align=\"center\">\n      <Flex w={[\"100%\", \"100%\", \"100%\"]} h=\"90%\" flexDir=\"column\">\n        <Header />\n        <Divider />\n        <Messages messages={messages} />\n        <Divider />\n        <Footer\n          inputMessage={inputMessage}\n          setInputMessage={setInputMessage}\n          handleSendMessage={handleSendMessage}\n        />\n      </Flex>\n    </Flex>\n  );\n});\n\nexport default ChatComponent;\n```\nThe registered channels are provided to each component in its props using\n`readonly ui_message_registry: OutputChannel[]`\nWhere OutputChannel is \n```\nexport interface OutputChannel {\n    readonly channel_id: ChannelId;\n    readonly channel_name: string;\n}\n```\nYou are supposed to perform one task based on the objective: {objective}. Take into account these previously completed tasks: {context}"},"inputSize":{"0":{"width":681,"height":376}},"id":"246c6422-25d3-4aa6-bc74-1152e3135ed8","outputChannelData":[]},"id":"246c6422-25d3-4aa6-bc74-1152e3135ed8","position":{"x":-448,"y":-144},"type":"regularNode","selected":true,"height":507,"width":706,"zIndex":70},{"data":{"schemaId":"machines:text:text_large","inputData":{"0":"    \"You are an task creation AI that uses the result of an execution agent\"\n    \" to create new tasks with the following objective: {objective},\"\n    \" The last completed task has the result: {result}.\"\n    \" This result was based on this task description: {task_description}.\"\n    \" These are incomplete tasks: {incomplete_tasks}.\"\n    \" Based on the result, create minimum number of new tasks to be completed\"\n    \" by the AI system that do not overlap with incomplete tasks.\"\n    \" Return the tasks as an array.\"\n"},"inputSize":{"0":{"width":515,"height":183}},"id":"2e08c4d4-1a59-5f88-9ba6-eff235a7428d","outputChannelData":[]},"id":"2e08c4d4-1a59-5f88-9ba6-eff235a7428d","position":{"x":-464,"y":768},"type":"regularNode","selected":false,"height":314,"width":540,"zIndex":50},{"data":{"schemaId":"machines:langchain:serp_tool","inputData":{},"id":"3cf66955-7054-4e05-b7b4-7117c44edeb1","isDisabled":true,"outputChannelData":[]},"id":"3cf66955-7054-4e05-b7b4-7117c44edeb1","position":{"x":208,"y":400},"type":"regularNode","selected":false,"height":99,"width":240,"zIndex":50},{"data":{"schemaId":"machines:langchain:plugins_list","inputData":{},"id":"429e1b36-087d-4f72-a7a8-3324335ad5cf","outputChannelData":[]},"id":"429e1b36-087d-4f72-a7a8-3324335ad5cf","position":{"x":592,"y":640},"type":"regularNode","selected":false,"height":214,"width":240,"zIndex":50},{"data":{"schemaId":"machines:text:text_large","inputData":{"0":"Question: {task}\n{agent_scratchpad}"},"inputSize":{"0":{"width":240,"height":80}},"id":"43f37d3a-9a30-5d25-8d81-9170c3a7bab5","outputChannelData":[]},"id":"43f37d3a-9a30-5d25-8d81-9170c3a7bab5","position":{"x":640,"y":1184},"type":"regularNode","selected":false,"height":211,"width":265,"zIndex":50},{"data":{"schemaId":"machines:text:text_large","inputData":{"0":"    \"You are an task prioritization AI tasked with cleaning the formatting of and re-prioritizing\"\n    \" the following tasks: {task_names}.\"\n    \" Consider the ultimate objective of your team: {objective}.\"\n    \" Do not add new tasks to the list.\"\n    \" Remove tasks that are unnecessary for the objective. Return the result as a numbered list, like:\"\n    \" #. First task\"\n    \" #. Second task\"\n    \" Start the task list with number {next_task_id}.\"\n"},"inputSize":{"0":{"width":582,"height":256}},"id":"6fb09ce9-33b4-5657-9b04-28dde6cfb0e8","outputChannelData":[]},"id":"6fb09ce9-33b4-5657-9b04-28dde6cfb0e8","position":{"x":-480,"y":1168},"type":"regularNode","selected":false,"height":387,"width":607,"zIndex":50},{"data":{"schemaId":"machines:langchain:python_repl","inputData":{},"id":"777e50e8-bcf7-4621-849f-d89250c89f6a","outputChannelData":[]},"id":"777e50e8-bcf7-4621-849f-d89250c89f6a","position":{"x":208,"y":768},"type":"regularNode","selected":false,"height":99,"width":240,"zIndex":50},{"data":{"schemaId":"machines:text:text_large","inputData":{"0":"You are an AI who performs one task based on the following objective: {objective}. Take into account these previously completed tasks: {context}."},"inputSize":{"0":{"width":544,"height":92}},"id":"77e9d3dd-8ed2-51e4-bb76-4ed30621ccfb","isDisabled":false,"outputChannelData":[]},"id":"77e9d3dd-8ed2-51e4-bb76-4ed30621ccfb","position":{"x":416,"y":928},"type":"regularNode","selected":false,"height":223,"width":569,"zIndex":50},{"data":{"schemaId":"machines:chat:chat_node","inputData":{"0":"Hi I am Oracle, the real one!"},"id":"7db6287b-ef38-49a6-a39a-1904bbb166b8","outputChannelData":[{"channel_name":"msg_from_chatbot","channel_id":"a81a26af-988a-46eb-a8ce-e6307a6c972c"},{"channel_name":"msg_from_user","channel_id":"913e2d59-4a8a-41c7-a71d-353450b8d567"}]},"id":"7db6287b-ef38-49a6-a39a-1904bbb166b8","position":{"x":1456,"y":1152},"type":"regularNode","selected":false,"height":456,"width":298,"zIndex":50},{"data":{"schemaId":"machines:chat:nodebuilder_agent","inputData":{"1":1000,"2":0.2,"3":1,"4":"","5":"","6":"","7":""},"inputSize":{"4":{"width":240,"height":80},"5":{"width":240,"height":80},"6":{"width":240,"height":80},"7":{"width":240,"height":80}},"id":"82eb147e-57a8-4a93-957d-9d47576a4e97","outputChannelData":[]},"id":"82eb147e-57a8-4a93-957d-9d47576a4e97","position":{"x":1072,"y":624},"type":"regularNode","selected":false,"height":727,"width":265,"zIndex":50},{"data":{"schemaId":"machines:langchain:wolfram_plugin","inputData":{},"id":"e1103fe5-ff39-4597-bf54-43b160b86b57","outputChannelData":[]},"id":"e1103fe5-ff39-4597-bf54-43b160b86b57","position":{"x":208,"y":640},"type":"regularNode","selected":false,"height":99,"width":240,"zIndex":50}],"edges":[{"id":"3161be11-48b4-4386-b2c1-90379e7bcb5a","sourceHandle":"82eb147e-57a8-4a93-957d-9d47576a4e97-0","targetHandle":"7db6287b-ef38-49a6-a39a-1904bbb166b8-1","source":"82eb147e-57a8-4a93-957d-9d47576a4e97","target":"7db6287b-ef38-49a6-a39a-1904bbb166b8","type":"main","animated":false,"data":{},"zIndex":49},{"id":"3de5204b-5c8a-43d3-9bb5-96add7c0bb5f","sourceHandle":"e1103fe5-ff39-4597-bf54-43b160b86b57-0","targetHandle":"429e1b36-087d-4f72-a7a8-3324335ad5cf-1","source":"e1103fe5-ff39-4597-bf54-43b160b86b57","target":"429e1b36-087d-4f72-a7a8-3324335ad5cf","type":"main","animated":false,"data":{},"zIndex":49,"selected":false},{"id":"50f679a3-6fdc-463c-8ecf-ee514fdd9f66","sourceHandle":"82eb147e-57a8-4a93-957d-9d47576a4e97-1","targetHandle":"7db6287b-ef38-49a6-a39a-1904bbb166b8-2","source":"82eb147e-57a8-4a93-957d-9d47576a4e97","target":"7db6287b-ef38-49a6-a39a-1904bbb166b8","type":"main","animated":false,"data":{},"zIndex":49},{"id":"5465011c-5e75-47aa-b4ab-2fe91a7b8cd3","sourceHandle":"429e1b36-087d-4f72-a7a8-3324335ad5cf-0","targetHandle":"82eb147e-57a8-4a93-957d-9d47576a4e97-0","source":"429e1b36-087d-4f72-a7a8-3324335ad5cf","target":"82eb147e-57a8-4a93-957d-9d47576a4e97","type":"main","animated":false,"data":{},"selected":false,"zIndex":49},{"id":"6da0f93c-b11c-4dbd-ac2b-4abd40fb2d1e","sourceHandle":"43f37d3a-9a30-5d25-8d81-9170c3a7bab5-0","targetHandle":"82eb147e-57a8-4a93-957d-9d47576a4e97-7","source":"43f37d3a-9a30-5d25-8d81-9170c3a7bab5","target":"82eb147e-57a8-4a93-957d-9d47576a4e97","type":"main","animated":false,"data":{},"zIndex":49},{"id":"876e0dc9-75b0-4230-8e5c-a3d3f07117d5","sourceHandle":"2e08c4d4-1a59-5f88-9ba6-eff235a7428d-0","targetHandle":"82eb147e-57a8-4a93-957d-9d47576a4e97-4","source":"2e08c4d4-1a59-5f88-9ba6-eff235a7428d","target":"82eb147e-57a8-4a93-957d-9d47576a4e97","type":"main","animated":false,"data":{},"zIndex":49},{"id":"931214eb-a8e8-499b-840c-18cac65aa82e","sourceHandle":"777e50e8-bcf7-4621-849f-d89250c89f6a-0","targetHandle":"429e1b36-087d-4f72-a7a8-3324335ad5cf-2","source":"777e50e8-bcf7-4621-849f-d89250c89f6a","target":"429e1b36-087d-4f72-a7a8-3324335ad5cf","type":"main","animated":false,"data":{},"zIndex":49,"selected":false},{"id":"b1c42453-af7c-4731-ad56-25882d511d74","sourceHandle":"77e9d3dd-8ed2-51e4-bb76-4ed30621ccfb-0","targetHandle":"82eb147e-57a8-4a93-957d-9d47576a4e97-6","source":"77e9d3dd-8ed2-51e4-bb76-4ed30621ccfb","target":"82eb147e-57a8-4a93-957d-9d47576a4e97","type":"main","animated":false,"data":{},"zIndex":49},{"id":"d73c338d-8681-4b29-b8a0-d324e51dac1b","sourceHandle":"11227109-271f-4756-8415-175f97c2b999-0","targetHandle":"429e1b36-087d-4f72-a7a8-3324335ad5cf-0","source":"11227109-271f-4756-8415-175f97c2b999","target":"429e1b36-087d-4f72-a7a8-3324335ad5cf","type":"main","animated":false,"data":{},"zIndex":49,"selected":false},{"id":"f51a4450-cab6-4b4f-9ba5-8c6410ef7bab","sourceHandle":"6fb09ce9-33b4-5657-9b04-28dde6cfb0e8-0","targetHandle":"82eb147e-57a8-4a93-957d-9d47576a4e97-5","source":"6fb09ce9-33b4-5657-9b04-28dde6cfb0e8","target":"82eb147e-57a8-4a93-957d-9d47576a4e97","type":"main","animated":false,"data":{},"zIndex":49}],"viewport":{"x":558.7488635394213,"y":-76.43845137705165,"zoom":0.6252516580669423}},"timestamp":"2023-05-09T08:37:49.608Z","checksum":"79846623a7ed99045d08a289a4f4f56d","migration":28}